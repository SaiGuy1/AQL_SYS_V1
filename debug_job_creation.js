// Script to debug job creation by showing how job data is being processed
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
import { sanitizeDraftForStorage } from './src/services/supabaseService.js';

dotenv.config();

// Initialize Supabase client
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY || process.env.SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('Error: SUPABASE_URL and SUPABASE_SERVICE_KEY/SUPABASE_ANON_KEY must be set in .env');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

// Sample job data with all fields as expected from the application
const sampleJobData = {
  id: null, // Will be generated by Supabase for new drafts
  title: "Test Job with All Fields",
  status: "draft",
  job_number: "DBG-" + Math.floor(Math.random() * 10000),
  location_number: "LOC-123",
  revision: "1",
  user_id: null, // Will get current user ID in real flow
  form_data: {
    step1: { field1: "value1", field2: "value2" },
    step2: { field3: "value3", field4: "value4" }
  },
  customer: {
    name: "Test Customer",
    email: "customer@example.com",
    phone: "555-1234"
  },
  location: {
    address: "123 Test St",
    city: "Test City",
    state: "TS",
    zip: "12345"
  },
  current_tab: "overview",
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString()
};

// Function to test the sanitization process
function testSanitizeDraftForStorage() {
  console.log('===== TESTING SANITIZE DRAFT FOR STORAGE =====');
  console.log('Original Job Data:');
  console.log(JSON.stringify(sampleJobData, null, 2));
  
  try {
    const sanitizedData = sanitizeDraftForStorage(sampleJobData);
    console.log('\nSanitized Job Data:');
    console.log(JSON.stringify(sanitizedData, null, 2));
    
    // Check specific fields that might cause issues
    console.log('\nKey Field Types After Sanitization:');
    console.log(`title: ${typeof sanitizedData.title}`);
    console.log(`status: ${typeof sanitizedData.status}`);
    console.log(`job_number: ${typeof sanitizedData.job_number}`);
    console.log(`form_data: ${typeof sanitizedData.form_data} (Should be string if JSON serialized)`);
    console.log(`customer: ${typeof sanitizedData.customer} (Should be string if JSON serialized)`);
    console.log(`location: ${typeof sanitizedData.location} (Should be string if JSON serialized)`);
  } catch (error) {
    console.error('Error during sanitization:', error);
  }
}

// Function to test direct insertion into Supabase
async function testDirectInsert() {
  console.log('\n===== TESTING DIRECT INSERT TO SUPABASE =====');
  
  try {
    // First get current user
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError) {
      console.error('Error getting user:', userError.message);
      console.log('Continuing with null user_id for testing...');
    }
    
    // Create job data with the user_id if available
    const jobData = {
      ...sampleJobData,
      user_id: user?.id || null
    };
    
    // First try direct insertion without sanitization
    console.log('Attempting direct insertion without sanitization...');
    const { data: directInsertData, error: directInsertError } = await supabase
      .from('jobs')
      .insert(jobData)
      .select()
      .single();
    
    if (directInsertError) {
      console.error('Direct insert error:', directInsertError.message);
      console.log('Error code:', directInsertError.code);
      console.log('Error details:', directInsertError.details);
      
      // Now try with sanitization
      console.log('\nAttempting insert with sanitization...');
      const sanitizedData = sanitizeDraftForStorage(jobData);
      console.log('Sanitized data for insert:');
      console.log(JSON.stringify(sanitizedData, null, 2));
      
      const { data: sanitizedInsertData, error: sanitizedInsertError } = await supabase
        .from('jobs')
        .insert(sanitizedData)
        .select()
        .single();
      
      if (sanitizedInsertError) {
        console.error('Sanitized insert error:', sanitizedInsertError.message);
        console.log('Error code:', sanitizedInsertError.code);
        console.log('Error details:', sanitizedInsertError.details);
        
        // Try a minimal insert with only required fields
        console.log('\nAttempting minimal insert with only required fields...');
        const minimalData = {
          title: "Minimal Test Job",
          status: "draft",
          job_number: "MIN-" + Math.floor(Math.random() * 10000),
          user_id: user?.id || null
        };
        
        const { data: minimalInsertData, error: minimalInsertError } = await supabase
          .from('jobs')
          .insert(minimalData)
          .select()
          .single();
        
        if (minimalInsertError) {
          console.error('Minimal insert error:', minimalInsertError.message);
        } else {
          console.log('Minimal insert successful!');
          console.log('Inserted data:', minimalInsertData);
        }
      } else {
        console.log('Sanitized insert successful!');
        console.log('Inserted data:', sanitizedInsertData);
      }
    } else {
      console.log('Direct insert successful!');
      console.log('Inserted data:', directInsertData);
    }
  } catch (error) {
    console.error('Unexpected error during test:', error);
  }
}

// Function to check the database schema
async function checkDatabaseSchema() {
  console.log('\n===== CHECKING DATABASE SCHEMA =====');
  
  try {
    // Check the jobs table structure
    const { data: columns, error: columnsError } = await supabase
      .from('information_schema.columns')
      .select('column_name, data_type, udt_name')
      .eq('table_schema', 'public')
      .eq('table_name', 'jobs');
    
    if (columnsError) {
      console.error('Error fetching schema:', columnsError.message);
    } else {
      console.log('Jobs table schema:');
      columns.forEach(col => {
        const type = col.data_type === 'USER-DEFINED' ? col.udt_name : col.data_type;
        console.log(`${col.column_name}: ${type}`);
      });
      
      // Specifically check the status column
      const statusColumn = columns.find(col => col.column_name === 'status');
      if (statusColumn) {
        console.log('\nStatus column details:');
        console.log(`Type: ${statusColumn.data_type}`);
        console.log(`UDT Name: ${statusColumn.udt_name}`);
        
        if (statusColumn.data_type === 'USER-DEFINED') {
          // If it's an enum, check the possible values
          const { data: enumValues, error: enumError } = await supabase.rpc('check_enum_values', { enum_name: statusColumn.udt_name });
          
          if (enumError) {
            console.error('Error fetching enum values:', enumError.message);
            
            // Fallback to a direct query
            const { data: pgEnumData, error: pgEnumError } = await supabase
              .from('pg_enum')
              .select('enumlabel')
              .eq('enumtypid', await supabase.rpc('get_type_oid', { type_name: statusColumn.udt_name }));
            
            if (pgEnumError) {
              console.error('Error with fallback enum query:', pgEnumError.message);
            } else {
              console.log('Status enum values:', pgEnumData.map(e => e.enumlabel));
            }
          } else {
            console.log('Status enum values:', enumValues);
          }
        }
      }
    }
  } catch (error) {
    console.error('Unexpected error checking schema:', error);
  }
}

// Main function to run the tests
async function main() {
  console.log('Starting job creation debug script...');
  
  // First test the sanitization function
  testSanitizeDraftForStorage();
  
  // Check the database schema
  await checkDatabaseSchema();
  
  // Test direct insertion to Supabase
  await testDirectInsert();
  
  console.log('\nDebug script complete');
}

main(); 